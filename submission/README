# DJ

# BV

# Simon

High Level

Note f is assumed to be 2d list or ndarray of 0s and 1s representing the function f
It's dimensions are 2^n x n.
The ith row is the integer representation of the binary string x.
f[i][j] is the jth bit of f(x).
f[x] is a list of bits representing f(x).

Import the file.

High Level:
>>> run_simon(f)

Output:
The program outputs progress messages as it goes. It prints each y it measures. It interprets the measurements and calulates s.
In order to allow s as a possible secret, f(0) must be compared against f(s). If they're equal s_calc is correct, otherwise f is 1 to 1 and s = 0.
run_simon(f) will call f twice to confirm the correct value of s.
The returned value will be a list of bits representing s.

Lower Level:

>>> uf = create_Uf(f)
>>> Uf_quil_def = DefGate("UF", uf)
>>> compile_time, qc, executable = compile_simon(Uf_quil_def, n, time_out_val)
>>> run_time, vectors_generated, s_calc = simon(n, qc, executable)
>>> print(s_calc)

This assumes no access to f. s_calc must be checked or it must be known before hand that s!= 0.

# Grover
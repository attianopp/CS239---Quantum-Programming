# DJ
First, import the module dj.py

The function f: {0,1}^n --> {0,1} which is either constant or balanced, is taken as input in the form of a numpy array of length 2**n. Each element of f is an integer 0 or 1.

# BV

# Simon

High Level

Note f is assumed to be 2d list or ndarray of 0s and 1s representing the function f
It's dimensions are 2^n x n.
The ith row is the integer representation of the binary string x.
f[i][j] is the jth bit of f(x).
f[x] is a list of bits representing f(x).

Import the file.

High Level:
>>> run_simon(f)

Output:
The program outputs progress messages as it goes. It prints each y it measures. It interprets the measurements and calulates s.
In order to allow s as a possible secret, f(0) must be compared against f(s). If they're equal s_calc is correct, otherwise f is 1 to 1 and s = 0.
run_simon(f) will call f twice to confirm the correct value of s.
The returned value will be a list of bits representing s.

Lower Level:

>>> uf = create_Uf(f)
>>> Uf_quil_def = DefGate("UF", uf)
>>> compile_time, qc, executable = compile_simon(Uf_quil_def, n, time_out_val)
>>> run_time, vectors_generated, s_calc = simon(n, qc, executable)
>>> print(s_calc)

This assumes no access to f. s_calc must be checked or it must be known before hand that s!= 0.

# Grover

grover.py contains a set of methods needed to run grovers algorithm in pyquil.
	
	Check_correctness: checks to make sure the f(x)=1 for the x output from Grover's algorithm returns true if true.
	Convert_n_bit_string_to_int: converts an int to an unsigned representation of an int
	Create_minus_gate: makes a unitary transformation that maps |x> to -|x>
	Create_zf: zf = (-1)^f(x)|x>, returns the identity matrix with -1 on the corresponding rows that f(x) returns 1
	Create_z0: z0 = -|x> if |x> = 0^n else |x>, returns the identity matrix with -1 on first row
	All_f: creates all possible functions that return f(x)=1 for a given number of qubits n, and number of inputs x that evaluate to 1
	Calc_lim: calculates how many iterations (k) of grovers algorithm should be ran to ensure it returns the correct value for a given number of qubits, and the number of inputs x that evaluate to 1
	Grover: runs grovers algorithim k times on the input oracle pyquil gate defintion z_f that corresponds to the oracle function f

To run grover(z0,zf,n,a) you need to input the corresponding gate definition for z0 and zf for n qubits, the number of qubits, and the number of inputs that evaluate to 1. grover() then returns the bit string |x> that corresponds to an input x that evaluates 1.
	This can be proven by the proof of grovers algorithm that applying G = -(H^n)zo(H^n)zf k times where k is proportional to the sqrt(2^n) sets the state of the qubits to match x with overwhelming probability.

To test correctness you can pass in the oracle function and the result of Grovers algorithm to check_correctness.

If you run it through the command line as the main argument to the python interpreter it runs exhaustive testing and benchmarking for n=1-6 qubits, with the results averaged over 5 trials, and every possible function with a=1 (the number of inputs to f(X) that equal 1 -> |x| s.t. f(x)=1 )

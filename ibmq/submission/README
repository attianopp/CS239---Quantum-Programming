# DJ
First, import the module dj.py

The function f: {0,1}^n --> {0,1} which is either constant or balanced, is taken as input in the form of a numpy array of length 2**n. Each element of f is an integer 0 or 1. The output of f corresponding to a bit string s is stored at f[d(s)], where d(s) corresponds to the decimal representation of string s. For example, for n=3, the value of f(011) will be stored at f[3], since the binary string 011 corresponds to the number 3.

All the code is organized in a class. First declare the class then to run:
There are three ways to implement the DJ algorithm:
1. (Recommended) For a high level implementation, call the function run(f). This function takes f as input, obtains the oracle Uf, creates and runs the circuit, and interprets the results. It runs by default on burlington. It returns the most frequent measurement.

>>> p = Program()
>>> counts, answer, assemble_time, run_time = p.run(f)
>>> print(answer)
# 0^n if f is constant
# ow f is balanced

2. For a lower level implementation, follow this sequence:
>>> p = Program()
>>> provider = IBMQ.enable_account(API_TOKEN)
>>> backend = provider.backends.ibmq_burlington
# create a gate from f
>>> uf = p.create_uf(n, f)
# build the dj circuit
>>> circuit = p.build_circuit(n, uf)
# measure the circuit h
>>> counts, assembly_time, run_time = p.measure(circuit, backend)
>>> print(counts)
# counts is a dictionary of counts of measurements

3. To get an aribitrary uf that runs on any machine
>>> p = Program()
>>> provider = IBMQ.enable_account(API_TOKEN)
>>> backend = provider.backends.ibmq_16_melbourne
>>> n = 10
>>> uf = p.get_uf(n, "constant0")
# f(x) = 0
>>> uf = p.get_uf(n, "constant1")
# f(x) = 0
>>> uf = p.get_uf(n, "balanced")
# f(x) is balanced
# build the dj circuit
>>> circuit = p.build_circuit(n, None, True, uf)
# measure the circuit h
>>> counts, assembly_time, run_time = p.measure(circuit, backend)
>>> print(counts)
# counts is a dictionary of counts of measurements

		
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# BV
First, import the module BV.py

The function f: {0,1}^n --> {0,1} which is satisfies f(x) = a . x + b, is taken as input in the form of a numpy array of length 2**n. Each element of f is an integer 0 or 1. The output of f corresponding to a bit string s is stored at f[d(s)], where d(s) corresponds to the decimal representation of string s. For example, for n=3, the value of f(011) will be stored at f[3], since the binary string 011 corresponds to the number 3.

There are three ways to implement the bv algorithm:
1. (Recommended) For a high level implementation, call the function run_BV(f). This function takes f as input, obtains the oracle Uf, creates and runs the circuit, and interprets the results. It returns the value of a as a string. Note the will call f(0) to determine b. It runs by default on burlington. It returns the most frequent measurement.

>>> p = Program()
>>> counts, answer, assemble_time, run_time = p.run(f)
>>> print(answer)
# prints (a,b) where f(x) = a . x + b

2. For a lower level implementation, follow this sequence:
>>> p = Program()
>>> provider = IBMQ.enable_account(API_TOKEN)
>>> backend = provider.backends.ibmq_burlington
# create a gate from f
>>> uf = p.create_uf(n, f)
# build the dj circuit
>>> circuit = p.build_circuit(n, uf)
# measure the circuit h
>>> counts, assembly_time, run_time = p.measure(circuit, backend)
>>> print(counts)
# counts is a dictionary of counts of measurements where each measurement represents a in reverse
>>> a = p.evaluate(counts)
# returns most frequent item
>>> b = f[0]

3. To get a simplified uf to run on any machine. Note this uses a hack where a, b are found classically and then used to build uf
>>> p = Program()
>>> provider = IBMQ.enable_account(API_TOKEN)
>>> backend = provider.backends.ibmq_16_melbourne
>>> n = 10
>>> uf = p.get_uf(n, f)
# build the dj circuit
>>> circuit = p.build_circuit(n, None, True, uf)
# measure the circuit h
>>> counts, assembly_time, run_time = p.measure(circuit, backend)
>>> print(counts)
# counts is a dictionary of counts of measurements
>>> a = p.evaluate(counts, False)
# returns most frequent item
>>> b = f[0]


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Simon's algorithm

First, import the module Simon.py

The function f: {0,1}^n --> {0,1}^n which is satisfies f(x) = f(y) iff x + y \in {0,s} , is taken as input in the form of a numpy array of length 2**n. Each element of f is a string of length n. The output of f corresponding to a bit string s is stored at f[d(s)], where d(s) corresponds to the decimal representation of string s. For example, for n=3, the value of f(011) will be stored at f[3], since the binary string 011 corresponds to the number 3.

Create a Program class instance p, using p = Program()
There are two ways to implement the DJ algorithm:
1. (Recommended) For a high level implementation, call the function simon_solution(f). This function takes f as input, obtains the oracle Uf, creates and runs the circuit, and interprets the results. It returns the values of s in the form of a list of bitstrings. The first element of this string will always be '0..0', with the remaining ones being the non-zero values predicted by Simon's algorithm.
2. For a lower level implementation, follow this sequence:
	>> p = Program()         
	#### define f here
	>>Uf = p.create_Uf(f)
	>>circ = p.get_Simon_circuit(Uf)
	>>counts = p.run_created_circuit(circ, num_shots = 20)
	>>list_y = [y for y in counts]
	>>list_s = p.s_solution(list_y)
	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Grover
grover is an object that contains all the relevant methods for Grover's algorithim as member functions
program is an object that runs grover on the IBM quantum hardware 
First, import the module grover.py

There are two ways to run the grover algorithm:

For a high level implementation, call the function program.run(f) to run on the quantum hardware, to run simulations use grover.run(f). This function takes f as input, obtains the oracle Uf, creates and runs the circuit, and interprets the results. It returns the value of the most frequent output measured from the quantum hardware.

>>> p = Program()
>>> counts, answer, assemble_time, run_time = p.run(f)
>>> print(answer)
# prints |x> such that f(x) == 1 

For a lower level implementation, follow this sequence:
>>> p = Program()
>>> provider = IBMQ.enable_account(API_TOKEN)
>>> backend = provider.backends.YOUR_FAVORITE_QC
# create a gate from f
>>> uf = p.create_uf(n, f)
# build the circuit
>>> circuit = p.build_circuit(n, uf)
# measure the circuit 
>>> counts, assembly_time, run_time = p.measure(circuit, backend)
>>> print(counts)
# counts is a dictionary of counts of measurements where each measurement represents |x> in reverse
>>> y = p.evaluate(counts)

